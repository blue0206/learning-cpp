DATA TYPES
short
int
long
float
double
long double
char - can hold any character.
bool - true or false.
auto - used in cases like range based for loop, arrays, etc. For example,
	   for (auto i : array)
	   {
	       <code>
	   }
	   here, auto recognizes the data type of array and assigns the same to i.


ESCAPE SEQUENCES (\)
\n - new line.
	 '\n' is a value of type char and can be stored in a variable of type char.
	 "\n" is a string made up of exactly one character. Thus, it ain't type char
	 	  and cannot be stored in type char.
\t - tab.
\a - alert.
\\ - backslash(\).
single/double quote inside quote - \' or \".
R" " - if there are many backslash(\) in a string.


PRECEDENCE RULES (in decreasing order of precedence)
1. Unary operators +, -, ++, --, and !
2. Binary arithmetic operations *, /, %
3. Binary arithmetic operations +, -
4. Boolean operations <, >, <=, >=
5. Boolean operations ==, !=
6. Boolean operation &&
7. Boolean operation ||


MODIFIER
const - const type IDENTIFIER{};
		for example, const int NUMBER_ONE{};
		the value of const variable will never change unless done so manually.

LOOPS
do-while loop - do
				{
					<code>
				} while(condition)
while - while(condition)
		{
		 	<code>
		}
for - for(init_variable; condition; increment/decrement)
	  {
	      <code>		
	  }
for loop (range based) - for (type variable : array)
						 {
							<code>
						 }
						 for example, int arr[] = {4, 5, 8, 16};
						 for (int i : arr)
						 {
							cout << i;
						 }
						 The OUTPUT is: 45816.
						 type name must be specified in this loop.
break; - ends the loop.
continue; - goes back to the start of the loop and continues. 


CONDITIONALS
if-else if- else - if(condition)
				   {
						<code>
				   }
				   else if(condition)
				   {
						<code>
				   }
				   else:
				   {
						<code>
				   }
switch statement - switch (variable)
				   {
						case value:
							<code>
							break;
						case value:
							<code>
							break;
						default:
							<code>
				   }
				   The value provided must be of same data type as variable.
				   default case useful in case of no match, but not must.
				   break; is necessary!
				   default doesn't need break; statement.


LOGIC
and - &&; true if both conditions satisfy.
or - ||; true even if one of conditions satisfy.
not - !; reverses true to false and vice-versa.


TYPE CONVERSION
//Converts 'int' to 'double' and vice-versa.
Formula:
int variable = static_cast<int>(double);
double variable = static_cast<double>(int);

Examples:
double change;
int variable = static_cast<int>(change);
//Puts the value of 'change' in 'variable' and converts its type to 'int.'

int change;
double variable = static_cast<double>(change);
//Puts the value of 'change' in 'variable' and converts its type to 'double.'


TYPE CASTING
static_cast<type>(input) //use this to change to any type. Example,
double answer;
answer = static_cast<double>(9)/2
This will give answer to be 4.5 rather than 4 (since 9 and 2 were type int).


DEBUNKING DECIMAL FORMULA
cout.setf(ios::fixed)
cout.setf(ios::showpoint)

Here, 'setf' means 'set flags.'
A 'flag' is an instruction to do something in one of TWO possible ways.
If a flag is given as an argument to setf, then the flag tells the computer to
write output to that stream in some specific way. 
The flag 'ios::fixed' displays number in fixed-point notation.
The flag 'ios::showpoint' displays the decimal point of the number.
The word 'flag' is used for something that can be turned on or off.


DISPLAY DECIMAL OUTPUT TO A SPECIFIC DECIMAL SPACE
cout.setf(ios::fixed)
cout.setf(ios::showpoint)
cout.precision(x)             //'x' represents the number of decimal spaces.
For Example:
2.3452342 is displayed as 2.34 when 'x' is 2.


FLAGS
.setf() - this function has the following flags:
		      ios::fixed -- disables e-notation.
			  				not set by default.
							setting this unsets ios::scientific.
			  ios::scientific -- enables e-notation.
			  					 not set by default.
								 setting this unsets ios::fixed.
			  ios::showpoint -- not set by default.
			  ios::showpos -- shows '+' before positive integers.
			  				  not set by default.
			  ios::right -- sets any width given to the right.
			  				set by default.
							unsets ios::left.
			  ios::left -- sets any width given to the left.
			  			   not set by default.
						   unsets ios::right. 

FUNCTIONS
call by value - type function(type parameter, type parameter)
				{
					<code>
				}
				only the value of argument is used.
Overloading a function name - if two or more function definitions have the same
							  function name, it is called overloading.
							  when overloading, either the no. of function
							  parameters or the type of parameter must be 
							  different.
void function - return no value.
				void function(parameter)
				{
					<code>
					return;    //return is optional.
				}
				it works like an executable statement.
call by reference - used to obtain input from user. 
					returns the variable itself.
					type function(type& variable)
					{
						cin >> variable
						//the user input is assigned to variable.
					}
					the argument is variable and the whole variable is used.
formal parameter - parameter used in function declaration and used in function
				   body.
argument - argument are filled in place of parameters when a function is called.
mixed calls - function calls with both call by value and call by reference.


ARRAYS
Declaration - type variable[n];
Indexed Variables - variable[0], variable[1], ..., variable[n]
Initializing array - example, int num[4] = {8, 11, 5, 16};
for loop (range based) - int arr[] = {4, 5, 8, 16};
						 for (int i : arr)
						 {
							cout << i;
						 }
						 The OUTPUT is: 45816.
pass by reference - in the above for loop, changes to i won't change array.
					However, if we use '&' to make i a reference parameter, we 
					can change array by changing i. Here:
					int arr[] = {4, 5, 8, 16};
					for (int& i : arr)
					{
						i++;
					}
					for (auto i : arr)
					{
						cout << i;
					}
					The OUTPUT is: 56917
array parameter - to provide a complete array as function parameter. Example:
				  void input(int a[], array_size)
				  {
				      for (int i=0; i < array_size; i++)
					  {
					      cin >> a[i];
					  }
					  cout << "The last array index is " << (size - 1) << '\n\;
				  }
				  int main()
				  {
				      int arr[5], size{5};
					  input(arr, size);
				  }
				  size must be declared equal to array size and must be passed 
				  along with arr for this parameter to work.
const array parameter - to prevent an array from being modified by a function,
						add a const modifier to it in function declaration.
						Example, consider the void function from previous
						example and change it in following way:
							void input(const int a[], array_size);
						This would prevent the function from modifying the array
						values and you'll still be able to insert values in it.
						NOTE: once used for particular type, then it must be
						used for every function using that type.


C++ STANDARD LIBRARIES

<iostream>
cin
cout
ios::app
.get()
.put()

<string>
char file_name[n] - stores a string of (n-1) characters.

<cmath>
sqrt(x) - square root of x (type double).
pow(x,y) -  exponents; x is number, y is power (use of type double recommended).
fabs(x) - absolute value of type float and double.
floor(x) - round-down 'x'.
ceil(x) - round-up 'x'.

<cstdio>

<cstdint>

<ctime>

<cstdlib>
abs(x) - absolute value of type int (example, abs(-4) = 4).
labs(x) - absolute value of type long.
exit (0) - Exits program and prompts for closing.
exit (1) - Exits the program immediately.
//'exit (1)' is used for errors and 'exit (0)' for all other reasons.

<iomanip>
These are functions used after insertion operator '<<'.
For example: endl, setw, setprecision.
setw is just like 'width' member function but is used after '<<'.
Example:
	cout << 10 << setw(4) << 20 << setw(8) << 30 << endl;
	will output the following:
	10  20      30
setprecision is just like member function 'precision' but is used after '<<'.
Example:
	cout.setf(ios::fixed);
	cout.setf(ios::showpoint);
	cout << setprecision(2) << 30.2 << endl << setprecision(5) << 50.4 << endl;
	will output the following:
	30.20
	50.40000

<cctype>
//Must be type "char"
toupper('a') = 'A';
tolower('A') = 'a';
isupper: returns true if uppercase   isupper('a') is false	isupper('A') is true
islower: returns true if lowercase   islower('A') is false	islower('a') is true
isalpha: returns true if alphabet    isalpha('$') is false	isalpha('h') is true
isdigit: returns true if digit	     isdigit('a') is false	isdigit('2') is true
isspace: returns true if whitespace  isspace('4') is false	isspace(' ') is true 	
		     					     isspace('\n') is true isspace('\t') is true

<cassert>
assert(boolean_expression);
To disable assert without removing library, just add "#define NDEBUG" before
#include <cassert>. That is,
	#define NDEBUG
	#include <cassert>

<fstream>
ifstream - define an input file stream variable.
ofstream - define an output file stream variable.
.get()
.put()
istream
ostream


RANDOM NUMBER GENERATION
//Library <ctime> and <cstdlib>
//Put the following code in body: srand (time(0));
//Function srand (seed random number generator) used only once.

srand (time(0));
int variable = (rand() % 6) + 1;

//The variable expression generates random number from 0  to 5.
//Replace 6 with any number 'n' to generate a random number from 0 to (n - 1).
//Don't place both srand and rand in a loop. Generate srand only once. 
//Generate rand when and you need a random number.


I/O STREAMS
ifstream - type for an input file stream.
ofstream - type for an output file stream.
.open() - connects file stream to a file.
		  for example, inStream.open("file.dat"); //inStream is variable of type
		  ifstream.
.close() - disconnects file stream from file.
		   for example, inStream.close();
.fail() - if a call to open fails, this function returns true. For example,
		  inStream.open();
		  inStream.fail();   //returns true if call to open fails.
.open("file", ios::app) - opens the file without erasing the existing content.
						  any input is hence, appended to the file. 
						  example, inStream.open("file.dat", ios::app);
Streams as function parameters - streams can be given as call by reference 
								 parameters in functions.
.get() - reads in one character of input and stores it in variable of type char.
		 for example, char next;
		 	 cin.get(next);	   //characters are stored in next, sent as input.
		 It is a member function exclusive to input stream.
.put() - takes in one argument of type char and outputs it.
		 for example. char next;
		     cout.put(next);    //characters are stored in next, sent as output.
		 It is a member function exclusive to output stream.
.putback() - takes in one argument of type char and places it back in the input
			 stream.
			 for example, char next;
				cin.putback(next);  //character stored in next putback in input.
			 It is a member function exclusive to input stream.
istream - used as function call by reference parameter.
		  can work as both cin and file-input stream.
		  for example,
		      function(istream& cin) can be used for cin.
			  function(istream& inStream) can be used in case of file-input.
		  to be defined using ifstream before use, that is: ifstream istream;
ostream - used as function call by reference parameter.
		  can work as both cout and file-output stream.
		  for example,
		      function(ostream& cout) can be used for cout.
			  function(ostream& outStream) can be used in case of file-output.
		  to be defined using ofstream before use, that is: ofstream ostream;
Default Arguments - function(parameter=argument);
					In case of istream, 
						function(istream& inStream=cin);
.eof() - member function exclusive to input stream. 
		 returns true at end of file, takes no arguments, can be used for loops.
		 for example, while(!inStream.eof())
		 			  {
					      <code>
					  }


OBJECTS
A variable with Functions and Data associated with it is called an object.
The functions are called 'member functions' or methods.
For example in the following declaration:
ifstream inStream.open("infile.dat");
ofstream outStream.open("outfile.dat");

inStream and outStream are objects with function open associated with them 
and data inside the .dat files. Both objects have different functions even
though the names are same (i.e. 'open'). Both function are slightly different.


CLASS
A 'type' with an Object as Variable is called a Class.
In the above example, ifstream and ofstream are class with objects inStream
and outStream as variables.
The object's class determines which member functions the object has.
